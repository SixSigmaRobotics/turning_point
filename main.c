#pragma config(Sensor, dgtl1,  cLimit,         sensorTouch)
#pragma config(Sensor, dgtl6,  enable,         sensorDigitalIn)
#pragma config(Sensor, dgtl11, b,              sensorDigitalIn)
#pragma config(Sensor, dgtl12, a,              sensorDigitalIn)
#pragma config(Motor,  port2,           leftFront,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftBack,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           catapult,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           intakeBackup,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           rightFront,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           rightBack,     tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform( VEX2)
#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"
#include "auton.h"
#include "functions.h"
#define DEADZONE 20

void pre_auton() {
	bStopTasksBetweenModes = true;
}

task autonomous() {
	//int which_auton1 = SensorValue(a);
	//int which_auton2 = SensorValue(b);
	//int e = SensorValue(enable);
	//int done  = 0;
	//	if (which_auton1 == 1 && done == 0) {
	//		middleFlag();
	//		done = 1;
	//	}
	//	else if (which_auton2 == 1 && done == 0) {
	//		stopAllTasks();
	//		done = 1;
	//	}
middleFlagImproved(
);
	//forwardFlip(1700);
	//backwardsFlag(1700);
}
int leftC = 0, rightC = 0, intakeC, catapultC = 0, flag = 1, \
catapultCPrev = 0, dirup = 1, dirdown = 0, dir = 1;
int leftM = 0, rightM = 0, intakeM, catapultM = 0, intakeB = 0;
int cvLimit;
task usercontrol() {


	while (true) {
		leftC = vexRT[Ch2];
		rightC = vexRT[Ch3];
		intakeC = vexRT[Btn5U] - vexRT[Btn5D];
		catapultCPrev = catapultC;
		catapultC = vexRT[Btn6U];
		cvLimit = SensorValue(cLimit);


		if(abs(leftC) > DEADZONE) {
			leftM = leftC;
			} else {
			leftM = 0;
		}

		if(abs(rightC) > DEADZONE) {
			rightM = rightC;
			} else {
			rightM = 0;
		}

		dirup  = vexRT[Btn8U];
		dirdown = vexRT[Btn8D];
		if(dirup == 1) {
			dir = 1;
		}
		else if (dirdown == 1) {
			dir = 0;
		}

		intakeM = 128*(intakeC);
		intakeB = -128*(intakeC);

		if(catapultC == 1 && cvLimit == 0) {
			catapultM = 120;
			} else if(catapultC == 1 && cvLimit == 1) {
			catapultM = 5;
			} else if(vexRT[Btn6D] == 1) {
			catapultM = 120;
			} else {
			catapultM = 0;
		}


		motor[intake] = intakeM;
		motor[intakeBackup] = intakeB;
		motor[catapult] = catapultM;
		if(dir == 0) {
			motor[leftFront] = -leftM;
			motor[leftBack] = -leftM;
			motor[rightFront] = -rightM;
			motor[rightBack] = -rightM;
			} else {
			motor[leftFront] = rightM;
			motor[leftBack] = rightM;
			motor[rightFront] = leftM;
			motor[rightBack] = leftM;
		}


	}
}
